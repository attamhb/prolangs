
Base on BOOK *COMMON LISP: A Gentle Introduction to Symbolic Computation* 
By: *David S. Touretzky Carnegie Mellon University*




*  COMMON LISP TUTORIAL
** What is common LISP
LISP stands for "List Processing." The name "LISP" reflects the central data
structure and processing paradigm of the language, which revolves around linked
lists.

*** Lisp Syntax:
Common Lisp uses a prefix notation known as S-expression syntax. Programs in
Common Lisp are written as nested lists of symbols and data.

#+BEGIN_EXAMPLE
(print "Hello, World!")

(defun factorial (n)
  (if (<= n 1)
      1
      (* n (factorial (- n 1)))))

(print (factorial 5)) ; Output: 120

#+END_EXAMPLE

*** Dynamic Typing:
Common Lisp is dynamically typed, meaning that variable types are determined at
runtime rather than being explicitly declared.

*** Automatic Memory Management:
Common Lisp features automatic garbage collection, which takes care of memory
management, freeing developers from manual memory allocation and deallocation.

*** Macros:
Common Lisp provides a powerful macro system that allows developers to extend
the language itself. Macros enable the creation of domain-specific languages and
facilitate metaprogramming.


** DATA STRUCTURES
*** LISTS 
#+BEGIN_SRC lisp    :results output 
  (setq numbers '(1 2 3 4 5))
  (print numbers)

  (setq fruits '(apple banana cherry))
  (print fruits)

#+END_SRC
*** ARRAYS

#+BEGIN_SRC lisp    :results output 
  (setq numbers #(1 2 3 4 5)) ;; create an array
  (setq fruits #("apple" "banana" "cherry"))
#+END_SRC
*** HASH TABLES
#+BEGIN_SRC lisp    :results output 

  (setq my-hash (make-hash-table :test 'equal))
  (puthash 'name "John" my-hash)
  (puthash 'age 30 my-hash)

  (print (gethash 'name my-hash)) ; Output: "John"
  (print (gethash 'age my-hash)) ; Output: 30
  
#+END_SRC
*** VECTORS
#+BEGIN_SRC lisp    :results output 


#+END_SRC
*** QUES & STACKS

** OPERATIONS 

*** Arithmetic Operations:

- Addition: (+ 2 3) ; Output: 5
- Subtraction: (- 5 2) ; Output: 3
- Multiplication: (* 4 5) ; Output: 20
- Division: (/ 10 2) ; Output: 5

*** Comparison Operations:

- Equality: (= 5 5) ; Output: T
- Inequality: (/= 4 2) ; Output: T
- Greater Than: (> 6 3) ; Output: T
- Less Than: (< 2 4) ; Output: T

*** String Operations:

- Concatenation: (concatenate 'string "Hello" " " "World") ;
  Output: "Hello World"

- Substring: (subseq "Lisp Programming" 5 14) ;
  Output: "Programming"

*** List Operations:
- Cons: (cons 1 '(2 3)) ; Output: (1 2 3)
- Car: (car '(1 2 3)) ; Output: 1
- Cdr: (cdr '(1 2 3)) ; Output: (2 3)
- Append: (append '(1 2) '(3 4)) ; Output: (1 2 3 4)
- Push:

*** Looping and Iteration:

Loop: (loop for i from 1 to 5 do (print i)) ; Output: 1 2 3 4 5
Map: (mapcar #'(lambda (x) (* x 2)) '(1 2 3 4 5)) ; Output: (2 4 6 8 10)

*** File Operations:

Reading a File: (with-open-file (stream "file.txt") (do ((line (read-line stream nil) (read-line stream nil))) ((null line)) (print line)))
Writing to a File: (with-open-file (stream "output.txt" :direction :output) (format stream "Hello, World!"))

*** Random Number Generation:

(random 10) ; Output: Random number between 0 and 9
These are just a few examples of the operations available in Common Lisp. Common Lisp provides a rich standard library with a wide range of functions to perform mathematical operations, string manipulations, list operations, file operations, and more. Additionally, Common Lisp allows defining user-defined functions and macros to extend its capabilities.
 
** CONDITIONALS

*** IF
#+BEGIN_SRC lisp    :results output 
  (if (oddp 11) 'odd 'even)
  (if (oddp 32) 'odd 'even)

  (defun my-abs (x)
    (if (< x 0) (- x) x))

  (defun symbol-test (x)
    (if (symbolp x) (list 'yes x 'is 'a 'symbol)
        (list 'no x 'is 'not 'a 'symbol)))

#+END_SRC


Write a function MAKE-EVEN that makes an odd number even by adding one to
it. If the input to MAKE-EVEN is already even, it should be returned
unchanged.

#+BEGIN_SRC    lisp :results output 
    (defun make-even (x)
      (if (oddp x) (+ x 1)
          (list 'no x 'is 'not 'a 'symbol)))

    (make-even 4)
#+END_SRC
Write a function FURTHER that makes a positive number larger by adding
one to it, and a negative number smaller by subtracting one from it. What
does your function do if given the number 0?


#+BEGIN_SRC    lisp :results output 
    (defun further (x)
      (+ x 1))
    (further 4)
#+END_SRC



Recall the primitive function NOT: It returns NIL for a true input and
T for a false one. Suppose Lisp didnâ€™t have a NOT primitive. Show
how to write NOT using just IF and constants (no other functions). Call
your function MY-NOT.


#+BEGIN_SRC    lisp :results output 
  (defun my-not (x)
    (if x
        nil
        t))
  (my-not (= 1 1))
#+END_SRC

Write a function ORDERED that takes two numbers as input and makes a list
of them in ascending order. (ORDERED 3 4) should return the list (3 4).
(ORDERED 4 3) should also return (3 4), in other words, the first and
second inputs should appear in reverse order when the first is greater
than the second.

#+BEGIN_SRC    lisp :results output 
  (defun ordered (x y)
    (if (> y x)
        (list x y)
        (list y x))) 
#+END_SRC

*** THE COND MACRO

#+BEGIN_SRC    lisp :results output 
  (defun compare (x y)
    (cond ((equal x y) 'numbers-are-the-same)
          ((< x y) 'first-is-smaller)
          ((> x y) 'first-is-bigger)))
#+END_SRC    

 Write a version of the absolute value function MY-ABS using COND
instead of IF.

#+BEGIN_SRC    lisp :results output 
  (defun my-abs (x)
    (cond ((< x 0) (- x))
          ((> x 0) x)
          ((= x 0) 0)))

#+END_SRC

#+BEGIN_SRC    lisp :results output 
  (defun shape-type (sides)
    (cond ((= sides 3) 'Triangle)
          ((= sides 4) 'Rectangle)
          ((= sides 5) 'Pentagon)
          ((= sides 6) 'Hexagon)
          (t 'Other)))

  (shape-type 3)  ; Returns 'Triangle
  (shape-type 4)  ; Returns 'Rectangle
  (shape-type 5)  ; Returns 'Pentagon
  (shape-type 6)  ; Returns 'Hexagon
  (shape-type 8)  ; Returns 'Other
  
#+END_SRC    

#+BEGIN_SRC lisp    :results output 

   (defmacro my-first-macro (input)

     )
#+END_SRC

*** COND AND PARENTHESIS ERRORS
*** THE AND AND OR MACROS



#+BEGIN_SRC lisp    :results output 

  (defun small-positive-oddp (x)
    (and (< x 100)
         (> x 0)
         (oddp x)))


  (defun gtest (x y)
    (or (> x y)
        (zerop x)
        (zerop y)))


#+END_SRC



*** BUILDING COMPLEX PREDICATES

#+BEGIN_SRC lisp    :results output 
  (defun how-alike (a b)
    (cond ((equal a b) 'the-same)
          ((and (oddp a) (oddp b)) 'both-odd)
          ((and (not (oddp a)) (not (oddp b)))
           'both-even)
          ((and (< a 0) (< b 0)) 'both-negative)
          (t 'not-alike)))

  (defun same-sign (x y)
    (or (and (zerop x) (zerop y))
        (and (< x 0) (< y 0))
        (and (> x 0) (> y 0))))


#+END_SRC

 Write a predicate called GEQ that returns T if its first input is greater
than or equal to its second input.

#+BEGIN_SRC lisp    :results output 

  (defun geq (x y)
    (and (or (< x y)  (= x y))))

#+END_SRC

** Variables and Side EFFECTS

** OOPS

** EMACS LISP
 
**  
